#!/usr/local/bin/node

// OpenJSCAD.org CLI interface, written by Rene K. Mueller <spiritdude@gmail.com>
// License: GPLv2
//
version = '0.008';
//
// Description:
//   openjscad <file> [-o <stl>]
// e.g.
//   openjscad test.jscad                    
//   openjscad test.jscad -o test.stl
//   openjscad test.jscad -o test.amf
//   openjscad test.scad -o testFromSCAD.jscad
//   openjscad test.scad -o test.stl
//   openjscad test.stl -o test2.stl      # reprocessed: stl -> jscad -> stl
//   openjscad test.amf -o test2.jscad    
//
// History:
// 2013/04/12: 0.008: reimplement parseAMF without jquery
// 2013/04/11: 0.007: support of alpha for AMF addded, bumping version
// 2013/04/05: 0.006: support of AMF added, requires node 0.8.1+
// 2013/03/25: 0.005: more sanity check on input and local installation support
// 2013/03/18: 0.004: STL .stl (binary & ascii) support (experimental via openscad.js)
// 2013/03/18: 0.003: OpenSCAD .scad support by Gary Hodgson's openscad-openjscad-translator module
// 2013/03/02: 0.002: proper installation of the dependencies (csg.js & openscad.js) so openjscad can be used properly
// 2013/03/01: 0.001: initial version, with base function from openscad.jscad
//

me = 'cli';
global.time = new Date();

var fs = require('fs');
var vm = require('vm');

//include('./openscad.js');         // later

global.lib = '/usr/local/lib/openjscad/';             // for now hard-coded
global.nodeModules = '/usr/local/lib/node_modules/';  // for now hard-coded too

//if (!fs.existsSync(global.lib))           // requires node 0.10.1 
//   global.lib = './';
if(!fs.statSync(global.lib).isDirectory())  // same but works with 0.6.1+
   global.lib = './';

var CSG = require(lib+'./csg.js').CSG;
var CAG = require(lib+'./csg.js').CAG;  // any way to include CSG & CAG in once?

//require(lib+'./OpenJsCad/openjscad.js'); // make it a nodejs module (later)

// hint: https://github.com/substack/node-optimist
//       https://github.com/visionmedia/commander.js
//
//process.argv.forEach(function (val, index, array) {
//  console.log(index + ': ' + val);
//});

var args = process.argv.splice(2);
var meta = [];

meta.producer = "OpenJSCAD "+me.toUpperCase()+" "+version;
meta.date = new Date();

var inf = args[0];
if(inf==null||inf.length<=0||!fs.statSync(inf).isFile()) {
   console.log("USAGE ("+version+"): openjscad <file> [-o <output>]\n\twhereas file: <name>.jscad, <name>.scad or <name>.stl\n\tand output: <name>.jscad or <name>.stl");
   process.exit(1);
}

var outf = inf;
outf = outf.replace(/\.[^\.]+$/,'.stl');

// output setting like openscad
if(args.length==2) {                         // -o<output>
   outf = args[1];
   outf = outf.replace(/^\-o(\S+)$/,'$1');
} else if(args.length==3&&args[1]=='-o') {   // -o <output>
   outf = args[2];
}

//console.log("reading "+inf);
var src = fs.readFileSync(inf,inf.match(/\.stl$/)?"binary":"UTF8");
var scad = fs.readFileSync(lib+'./openscad.js');
var inc = [];

//var csg = sphere(1);          // -- basic test
//var csg = require(file).main; // -- treating .jscad as module? later perhaps

var outFormat, inFormat;

if(inf.match(/\.(jscad|scad|stl|amf)$/)) {
   inFormat = RegExp.$1;
} else {
   console.log("ERROR: only jscad, scad, stl or amf as input format");
   process.exit(1);
}

if(outf.match(/\.(jscad|stl|amf)$/)) {
   outFormat = RegExp.$1;
} else {
   console.log("ERROR: only jscad, stl or amf as output format");
   process.exit(1);
}

console.log("converting "+inf+" -> "+outf);

// -- include input, and convert into JSCAD source
if(inFormat=='scad') {
   //var scadParser = require('openscad-openjscad-translator');     // npm installed but doesn't find it (crap!)
   var scadParser = require(global.nodeModules+'openscad-openjscad-translator');  // hardcoded is bad, but works
   src = scadParser.parse(src); //    doing the magick
   src = "// producer: OpenJSCAD "+me.toUpperCase()+" "+version+"\n"+src;
   src = "// source: "+outf+"\n\n"+src;
   
} else if(inFormat=='stl') {
   //console.log("converting "+inf+" to jscad");
   var openscad = require(lib+'openscad.js');
   src = openscad.parseSTL(src,inf);
   //src = "// "+outf+" created by openjscad-"+version+" from "+inf+"\n\n"+src;
   
} else if(inFormat=='amf') {
   //console.log("converting "+inf+" to jscad");
   // $ = require(global.nodeModules+'jquery');   // needed for AMF (XML) parsing
   // var openscad = require(lib+'openscad.js');
   // src = openscad.parseAMF(src,inf);
   src = parseAMF(src,inf);
   //src = "// "+outf+" created by openjscad-"+version+" from "+inf+"\n\n"+src;
   
} else {
   // jscad
   ;
}

// -- convert from JSCAD into suitable format wanted
if(outFormat=='jscad') {
   out = src;
} else {
   //console.log("render jscad to "+outFormat);
   var csg = eval(src+"\n"+scad+"\nmain()\n");    // *.jscad + openscad.js + main()
   if(csg.length) {
      var o = csg[0];
      for(i=1; i<csg.length; i++) {
         o = o.unionForNonIntersecting(csg[i]);
      }
      csg = o;
   }
   //var stl = csg.fixTJunctions().toStlBinary();   // creates a Blob, which with nodejs doesn't exist yet
   //var stl = csg.fixTJunctions().toStlString();     // creates bad facet normals!! in some cases
   var out;
   if(outFormat=='amf') {
      out = csg.toAMFString(meta);
   } else {
      // out = csg.toStlBinary();            // TODO: already uses Blob in csg.js, needs to be removed and put into openjscad.js
      out = csg.toStlString();
   }
}

var s = fs.WriteStream(outf);
s.write(out);

// -- helper functions 

function include(fn) {    
   //console.log(arguments.callee.caller,"include:"+fn);
   if(0) {
      //var script = vm.createScript(fs.readFileSync(fn),fn);
      //script.runInThisContext();
      var script = vm.runInThisContext(fs.readFileSync(fn),fn);
      return script;
   } else if(0) {
      inc.push(fn);
      
   } else {
      var src = fs.readFileSync(fn);
      //console.log("exec",src);
      var r;
      try {
         r = eval(src+scad);
      } catch(e) {
         if(e instanceof SyntaxError) {
            console.log(e.message);
         }
      }
      //echo("result:",r);
      return r;
   }
}

function getXMLContent(s,tag) { 
   var match = '/<\/'+tag+'>/';
   var m = s.split(match);
   var r = [];
   for(var i=0; i<s.length; i++) {
      match = '/.*<'+tag+'(.*)>/';
      if(!m[i]) 
         continue;
      var content = m[i].replace(match);
      var attr = [];
      if(RegExp.$1) {
         var a = RegExp.$1;
         // processing ' something="this" that="here"' .. (later)
      }
      if(content.length) 
         r.push({ text: content, attr: attr });
   }
   return m;
}

function parseAMF(amf,fn) {      // re-implemented since node-jquery doesn't do parse.XML (great!)
   var vt = [];                  // works: color per volume
   var tt = [];                  // missing: materials neither color per triangle (fix it)
   var co = [];
   var meta = [];

   var metadata = amf.split(/<\/metadata>/);
   metadata.forEach(function(v,i) {
      if(v.match(/<metadata\s+type="([^"]+)"\s*>(.*)/))
         meta[RegExp.$1] = RegExp.$2;
   });
   
   var mesh = amf.split(/<\/mesh>/);
   mesh.forEach(function(v,i) {
      var vertices = v.split(/<\/vertices>/);
      vertices.forEach(function(v,i) {
         var vertex = v.split(/<\/vertex>/);
         vertex.forEach(function(v,i) {
            var coordinates = v.split(/<\/coordinates>/);
            coordinates.forEach(function(v,i) {
               var xyz = v.split(/<\/[xyz]/);
               var coord = [];
               xyz.forEach(function(v,i) {
                  //console.log("==="+v);
                  if(v.match(/[xyz]>([^<]+)/)) 
                     coord.push(RegExp.$1);
               });
               if(coord.length==3) {
                  //console.log("vertex: "+coord);
                  vt.push(coord);
               }
            });
         });
      });
      var volume = v.split(/<\/volume>/);
      volume.forEach(function(v,i) {
         var triangle = v.split(/<\/triangle>/);
         var color = v.split("<\/color>");
         var rgbv = [];
         color.forEach(function(v,i) {
            var rgba = v.split(/<\/[rgba]>/);
            rgba.forEach(function(v,i) {
               if(v.match(/<[rgba]>(\S+)/))
                  rgbv.push(RegExp.$1);
            });
         });
         triangle.forEach(function(v,i) {
            var faces = v.split(/<\/v[123]>/);
            var fc = [];
            faces.forEach(function(v,i) {
               if(v.match(/<v[123]>(\d+)/))
                  fc.push(RegExp.$1);
            });
            if(fc.length==3) {
               tt.push(fc);
               if(rgbv.length) 
                  co[tt.length-1] = rgbv;
            }
         });
      });
   });

   // vt[] has the vertices
   // tt[] has the faces
   var srci = '', err = '';
   var np = 0; 
   
   srci = "\tvar pgs = [];\n";
   
   for(var i=0; i<tt.length; i++) {
      //srci += "\tpgs.push(new CSG.Polygon([\n\t\t";
      srci += "\tpgs.push(PP([\n\t\t";
      for(var j=0; j<tt[i].length; j++) {
         if(tt[i][j]<0||tt[i][j]>=vt.length) {
            if(err.length=='') err += "bad index for vertice (out of range)";
            continue;
         }
         if(j) srci += ",\n\t\t";
         srci += "VV("+vt[tt[i][j]]+")";
      }
      srci += "])";
      if(co[i]) srci += ".setColor("+co[i]+")";
      srci += ");\n";
      np++;
   }
   var src = "";
   for(var k in meta) {
      src += "// AMF."+k+": "+meta[k]+"\n";
   }
   src += "// producer: OpenJSCAD "+me.toUpperCase()+" "+version+" AMF Importer\n";
   src += "// date: "+(new Date())+"\n";
   src += "// source: "+fn+"\n";
   src += "\n";
   
   if(err) src += "// WARNING: import errors: "+err+" (some triangles might be misaligned or missing)\n";
   src += "// objects: 1\n// object #1: polygons: "+np+"\n\n";
   src += "function main() {\n"; 
   src += "\tvar PP = function(a) { return new CSG.Polygon(a); }\n"; 
   src += "\tvar VV = function(x,y,z) { return new CSG.Vertex(new CSG.Vector3D(x,y,z)); }\n";
   //src += vt2jscad(v,f,[],c);
   src += srci;
   src += "\treturn CSG.fromPolygons(pgs);\n}\n";
   return src;
   
}

